Code Page x Unicode

O SQL armazena número não letras etc
Utiliza uma tabela de conversão ex:
	35 = a (a minúsculo) 
	36 = c (c minúsculo)

Existem 2 tipos de tabela de conversão 
	-> Code Page
	-> Unicode

Code Page
	
	-> mais antiga
	-> cada caractere utiliza 1 byte para ser armazenado
	-> cada caractere é armazenado como um número
	-> máximo de 256 caracteres (não cabem todos os caracteres do mundo)
	-> criaram mais de uma Code Page mudando os caracteres de acordo com a língua 
	Exemplos: 
	Code Page 437 -> Voltada para Inglês, não possui acentuação 
	Code Page 850 -> Chamada de multilíngue (atende várias línguas inclusive o português), tem acentuação
	-> Os primeiros 128 caracteres são sempre idênticos para todas as Code Pages (todas as letras de "a" a "z" maiúscula e minúscula sem acentuação, números de "0" a "9")
	-> Na segunda faixa acima do 128 temos os caracteres especiais (essa é que muda de Code Page para Code Page)
	
	B.O. exemplo:
	Tenho um banco com Code Page 850 se transportar os dados para um outro banco com Code Page 437 o meu "á" por exemplo vai chegar lá e vai aparecer um "carinha sorrindo" 
	ou seja, o "á" não existe naquela Code Page

	Problema com a Code Page é que na troca de informações entre bancos com Code Page diferentes há risco de perda de caracteres 

	-> É usado quando utilizo os seguintes tipos de dados: CHAR, VARCHAR e TEXT
	-> CHAR(10) = 10 bytes


Unicode 
	
	-> codificação única
	-> mais recente
	-> cada caractere utiliza 2 bytes para ser armazenado
	-> cada caractere é armazenado como um número
	-> máximo de 65.563 caracteres (sem risco de perda de acentos e símbolos) - CABE TODOS OS CARACTERES/SIMBOLOS/LETRAS/NUMEROS EXISTENTES NO MUNDO
	-> É usado quando utilizo os seguintes tipos de dados: NCHAR, NVARCHAR e NTEXT
	-> NCHAR(10) = 20 bytes (ocupa o dobro do espaço)
	-> Nesse temos um prejuízo no desempenho (maior quantidade de dado armazenado maior é o número de IO, portanto consome mais recursos)


Collation
	
	-> define regras de armazenamento e manipulação de caracteres
	-> Latin1_General_CI_AS -> Code Page 1252
	-> Quando não está explicito na Collation o "CP" significa que está usando a Code Page padrão para banco de dados relacional (definido pela padronização ANSI)
	-> CI = Case Insensitive
	-> CS = Case Sentitive
	-> AS = Accent Sentitive
	-> AI = Accent Insensitive
	
	-> Windows Collation	-> Sempre que possível utilizar essa (sem o "SQL_" na frente do nome)
	-> SQL Collation	-> Começa com "SQL_" = SQL+underscore (Ex: SQL_Latin1_General_CP1_CI_AS). Mantida para compatibilidade com SQL 7, SQL 2000...
	-> Quanto mais bancos com a mesma Collation menos a quantidade de problema



Ordem da Collation
	-> Ordem Binária	-> Se terminar com BIN é porque usa Ordem Binária (Latin1_General_BIN) (ABCD...XYZabcd)
	-> Ordem Dicionário	-> (AaBbCc...)
	-> Aplicações mais antigas usavam Ordem Binária

	TEMPDB -> ele é criado com a Collation que é usada na instalação do SQL Server 
	
	Ex problema 1: 
	-> Criado banco de dados com a CP 437 = TEMPDB é criado com a CP 437
	-> Criado outro banco de dados com a Collation Padrão 1252 que tem acentos
	-> Executo um SELECT grande onde uso de um ORDER BY mas não tem espaço suficiente em memória, o SQL vai usar o TEMPDB
	-> O que vai ocorrer é que vai pegar os dados em 1252 e vai copiar lá para TEMPDB que está com 437, vai matar com todos os acentos e vai ordenar 
	-> Quando vai mostrar para o usuário vai estar tudo bugado

	Ex problema 2: 
	-> 2 bancos com Collation diferentes ao tentar fazer um JOIN vai dar problema na hora de comparar as colunas (possivelmente erro)
	-> Na query tem que fazer o tratamento implicitamente informando qual Collation que tem que usar 
	-> Impacta diretamente no desempenho 
	-> Os índices do banco não prestam pra nada nesse caso 

	-> PROCESSO DOLOROSO (ALTERAR A COLLATION) EXTREMAMENTE COMPLEXO
	-> Se só trocar a Collation só os dados desse momento em diante que vão estar na nova Collation, o que já existia no banco se mantem na Collation antiga
	-> Pra fazer essa troca teria que remover TODAS AS CONSTRAINTS, TODAS AS PRIMARY KEY, FOREING KEY + outras + Fazer rebuild de todas as tabelas alterando a Collation e por fim voltar tudo de novo constraits, chaves etc 





























	